= pick

A Clojure library for HTTP server-driven content negotiation.

[WARNING]
--
STATUS: Alpha. Still fresh, some development remaining.
--

== Quick Start

Suppose you are writing a web service and want to provide proactive content negotiation based on the accept headers in the client request. Suppose also that have established which variants you want to choose between.

A variant is represented by data, for example:

[source,clojure]
----
{:juxt.http/content-type
  {:juxt.http/type "text"
   :juxt.http/subtype "html"
   :juxt.http/parameter-map {"charset" "utf-8"}}
 :juxt.http/content-encoding
   [{:juxt.http/content-coding "gzip"}]
 :juxt.http/content-language
   {:juxt.http/langtag "en-US"}}
----

You can use *pick* to select the variant that is most acceptable to the user agent. Here's how:

[source,clojure]
----
(require
  '[juxt.pick.alpha.core :refer [pick]]
  '[juxt.pick.alpha.apache :refer [using-apache-algo]])

(pick
  using-apache-algo
  {:juxt.http/request-headers {…}
   :juxt.http/variants […]})
=>
{:juxt.http/variants [{…}]; most acceptable variant(s)
 :juxt.http/vary […] ; request headers used in the determination
}

----

== Introduction

Content negotiation is a feature of HTTP that allows different 'representations'
to be served from the same URI.

*pick* is a Clojure library that determines quality values of each of the
negotiable dimensions and corresponding rules specified in RFC 7231. These can
be used by content negotiation algorithms to determine the most appropriate
content to respond with.

*pick* _also_ includes a built-in reference implementation based on Apache's _de-facto_ https://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm[content negotiation algorithm].

=== Problem Statement

Content negotiation is one of the primary ways that the web is
inclusive, supporting a wide range of user agents and other software-based
clients.

Content negotiation can also contribute to improved performance, by allowing the
compression of content for optimising network bandwidth and by cache
integration.

Also, since content negotiation allows for gradual migration from old to new
data formats it enables graceful and continuous improvement, balancing the needs
for both innovation and solid dependability.

However, while content negotiation is often used for static resources, which is
well implemented by web servers such as Apache's httpd and nginx, it is often
missing from, or poorly implemented by, the majority of web libraries and
frameworks.

=== Alternatives

Most Clojure alternatives only deal with media-types, and perhaps charsets. Note
that *pick* fully implements _all_ proactive (server-driven) content negotiation
rules contained in https://tools.ietf.org/html/rfc7231[RFC 7231], including
media-types, charsets, encodings, languages, wildcards, qvalues and precedence
rules. Where not prescribed specifically by the RFC, *pick* adopts the
_de-facto_ decisions made by the Apache httpd engine.

https://github.com/ngrunwald/ring-middleware-format[ring-middleware-format] and
Metosin's https://github.com/metosin/muuntaja[Muuntaja] library negotiate
media-types and charsets, and perform automatic decoding/encoding of
request/response bodies

[CAUTION]
--
*pick* only provides the decision of which variant(s) to select,
given the context of an HTTP request and a set of variants to choose between.

It does *not* include support for format transformation or coercion, which is
_not considered in scope_ for this library.
--

https://github.com/clojure-liberator/liberator/commits/master[Liberator]

https://github.com/juxt/yada[yada]


== Documentation

NOTE: TBD

=== Variants

[source,clojure]
----
{:juxt.http/content-type
  {:juxt.http/type "text"
   :juxt.http/subtype "html"
   :juxt.http/parameter-map {"charset" "utf-8"}}
 :juxt.http/content-encoding
   [{:juxt.http/content-coding "gzip"}]
 :juxt.http/content-language
   {:juxt.http/langtag "en-US"}}
----

=== Selecting a variant

Use the `juxt.pick.alpha.core/pick` function, with the algorithm as
the first argument.

[TIP]
--
If you prefer to specify these values as string literals, use our https://github.com/juxt/reap[reap] library.

[source,clojure]
----
(require '[juxt.reap.alpha.decoders :as reap]

{:juxt.http/content-type (reap/content-type "text/html;charset=utf-8")
 :juxt.http/content-encoding (reap/content-encoding "gzip,deflate")
 :juxt.http/content-language (reap/content-language "en-US")
}
----

--

NOTE: Document the argument map

=== Media-types

NOTE: TBD

=== Charsets

NOTE: TBD

=== Encodings

NOTE: TBD

=== Languages

NOTE: TBD

=== A footnote on the `juxt.http` keyword namespace

The `juxt.http` namespace is used because it is managed by JUXT, to ensure
keywords in the `juxt.http` namespace are used consistently between libraries,
maintaining a 'registry' of these keywords, specifying the allowed data types,
publishing Clojure specs for import and so on. It is expected that users will
either be happy to use these namespaced keywords in their own programs or write
transformers to adapt their own data for use by pick.

It is recommended to retain the `juxt.http` namespace because of the benefit of
using other current and future JUXT libraries that integrate with *pick*.

== References

https://tools.ietf.org/html/rfc7231[RFC 7231] is the normative standard on content negotiation.

This https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation[MDN guide on content negotiation from Mozilla] is very informative.

https://httpd.apache.org/docs/current/en/content-negotiation.html#algorithm
